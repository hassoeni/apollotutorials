import { extendType, intArg, nonNull, objectType, stringArg } from 'nexus'
import { NexusGenObjects } from '../../nexus-typegen'

export const Link = objectType({
	//0 objectType is used to create a new type in your GraphQL schema.
	name: 'Link', // 1: The name option defines the name of the type

	definition(t) {
		// 2: Inside the definition, you can add different fields that get added to the type
		t.nonNull.int('id') // 3: This adds a field named id of type Int
		t.nonNull.string('description') //4
		t.nonNull.string('url') //5
	},
})

let links: NexusGenObjects['Link'][] = [
	// 1: The links variable is used to store the links at runtime. For now, everything is stored only in-memory rather than being persisted in a database.
	// Youâ€™re also using the Link interface generated by Nexus to define the type of the links variable as an array of Link objects.
	{
		id: 1,
		url: 'www.howtographql.com',
	},
	{
		id: 2,
		url: 'graphql.org',
		description: 'GraphQL official website',
	},
]

export const LinkQuery = extendType({
	// 2: You are extending the Query root type and adding a new root field to it called feed.
	type: 'Query',
	definition(t) {
		t.nonNull.list.nonNull.field('feed', {
			// 3: You define the return type of the feed query as a not nullable array of link type objects (In the SDL the return type will look like this: [Link!]!).
			type: 'Link',
			resolve(parent, args, context, info) {
				// 4: resolve is the name of the resolver function of the feed query. A resolver is the implementation for a GraphQL field. Every field on each type (including the root types)
				// has a resolver function which is executed to get the return value when fetching that type. For now, our resolver implementation is very simple, it just returns the links array.
				// The resolve function has four arguments, parent, args, context and info. We will get to these later.
				return links
			},
		})
	},
})

// what to do after each api requests for example create a new post that increments id
export const LinkMutation = extendType({
	//1  Youâ€™re extending the Mutation type to add a new root field. You did something similar in the last chapter with the Query type.
	type: 'Mutation',
	definition(t) {
		t.nonNull.field('post', {
			// 2: The name of the mutation is defined as post and it returns a (non nullable) link object.
			type: 'Link',
			args: {
				// 3: Here you define the arguments to your mutation. You can pass arguments to your GraphQL API endpoints (just like in REST).
				// In this case, the two arguments you need to pass are description and url. Both arguments mandatory (hence the nonNull()) because both are needed to create a new link.
				description: nonNull(stringArg()),
				url: nonNull(stringArg()),
			},

			resolve(parent, args, context) {
				const { description, url } = args // 4: Youâ€™re now using the second argument thatâ€™s passed into all resolver functions: args. Any guesses what itâ€™s used for? â€¦ Correct! ğŸ’¡
				// It carries the arguments for the operation â€“ in this case the url and description of the link to be created.

				let idCount = links.length + 1 // 5: idCount serves as a very rudimentary way to generate new id values for our link objects. Finally, you add your new link object to the links array and return the newly created object.
				const link = {
					id: idCount,
					description: description,
					url: url,
				}
				links.push(link)
				return link
			},
		})
	},
})

//  extend the GraphQL API with full CRUD functionality for the Link type. In particular, implement the queries and mutations that have the following definitions:
// type Query {link(id: ID!): Link}
// type Mutation {updateLink(id: ID!, url: String, description: String): Link!  deleteLink(id: ID!): Link!}
//! TODO SOLVE CHALLENGE
export const UpdateMutation = extendType({
	type: 'Mutation',
	definition(t) {
		t.nonNull.field('updateLink', {
			type: 'Link',
			args: {
				id: nonNull(intArg()),
				url: stringArg(),
				description: stringArg(),
			},
			resolve(parent, args, context) {
				let updatedLink

				links = links.map((link) => {
					if (link.id === args.id) {
						updatedLink = { ...link, ...args }
						return updatedLink
					}
					return link
				})
				return updatedLink
			},
		})
	},
})

export const DeleteMutation = extendType({
	type: 'Mutation',
	definition(t) {
		t.nonNull.field('deleteLink', {
			type: 'Link',
			args: {
				id: nonNull(intArg()),
			},
			resolve(parent, args, context) {
				const index = links.findIndex((link) => link.id === args.id)
				const link = links[index]
				links.splice(index, 1)
				return link
			},
		})
	},
})
